
USE DataWarehouseAnalytics;
-- Explore all objects in the Database
SELECT * FROM INFORMATION_SCHEMA.TABLES;

-- Explore all columns in the Database
SELECT * FROM INFORMATION_SCHEMA.COLUMNS
WHERE TABLE_NAME = 'dim_customers';
[gold].[fact_sales]
-- Explore Dimensions
SELECT DISTINCT country FROM gold.dim_customers;
SELECT DISTINCT category, subcategory, product_name FROM gold.dim_products
ORDER BY 1,2,3;

-- Explore Dates
SELECT 
    MIN(order_date), 
    MAX(order_date),
    MIN(shipping_date), 
    MAX(shipping_date),
    DATEDIFF(MONTH, MIN(order_date), MAX(order_date)) AS DateRangeInMonths
FROM gold.fact_sales

-- Find youngest and oldest customers
SELECT 
    MIN(birthdate) AS OldestCustomerBirthdate,
    MAX(birthdate) AS YoungestCustomerBirthdate,
    DATEDIFF(YEAR, MIN(birthdate), MAX(birthdate)) AS AgeRangeInYears
FROM gold.dim_customers;

-- Metrics:
-- Total Sales
SELECT 
    SUM(sales_amount) AS TotalSalesAmount,
    AVG(price) AS AveragePrice,
    SUM(quantity) AS TotalUnitsSold,
    COUNT(DISTINCT order_number) AS TotalOrders,
    COUNT(DISTINCT customer_key) AS TotalCustomersplacedOrders,
    COUNT(DISTINCT product_key) AS TotalNumberOfProductsSold
FROM gold.fact_sales;

SELECT 
   COUNT(DISTINCT customer_id) AS TotalCustomers
FROM gold.dim_customers;

SELECT 
    COUNT(DISTINCT product_key) AS TotalProducts
FROM gold.dim_products;

-- Generate a report using all key metrics of business
SELECT 'Total Sales' AS measure_name, SUM(sales_amount) AS measure_value FROM gold.fact_sales fs   
UNION ALL 
SELECT 'AveragePrice' AS measure_name ,  AVG(price) AS measure_value FROM gold.fact_sales
UNION ALL
SELECT 'TotalUnitsSold' AS measure_name , SUM(quantity) AS measure_value FROM gold.fact_sales
UNION ALL
SELECT 'TotalOrders' AS measure_name, COUNT(DISTINCT order_number) AS measure_value FROM gold.fact_sales
UNION ALL
SELECT 'TotalCustomersplacedOrders' AS measure_name, COUNT(DISTINCT customer_key) AS measure_value FROM gold.fact_sales
UNION ALL
SELECT 'TotalNumberOfProductsSold' AS measure_name , COUNT(DISTINCT product_key) AS measure_value FROM gold.fact_sales
UNION ALL 
SELECT 'TotalProducts' AS measure_name , COUNT(DISTINCT product_key) AS measure_value FROM gold.dim_products;


-- Magnitude Values: Measure by Dimension
-- Total number of customers by the countries
SELECT 
    country,
    COUNT(customer_key) AS total_customers
FROM gold.dim_customers
GROUP BY country
ORDER BY total_customers DESC

-- Find total customers by gender
SELECT 
    gender,
    count(customer_key) AS total_customers
FROM gold.dim_customers
GROUP BY gender

-- Find total products by category
SELECT 
    category,
    COUNT(product_key) AS total_products
FROM gold.dim_products
GROUP BY category
ORDER BY total_products DESC

-- Average cost in each category
SELECT 
    category,
    AVG(cost) AS avg_cost
FROM gold.dim_products
GROUP BY category
ORDER BY avg_cost DESC

SELECT * FROM gold.dim_products

-- What is the total revenue generated for each category?
SELECT 
p.category,
SUM(f.sales_amount) total_revenue
FROM gold.fact_sales f
LEFT JOIN
gold.dim_products p
ON f.product_key = p.product_key
GROUP BY p.category
ORDER BY total_revenue DESC

-- What is the total revenue generated by each customer?
SELECT 
c.customer_key,
c.first_name,
c.last_name,
SUM(f.sales_amount) total_revenue
FROM gold.fact_sales f
LEFT JOIN
gold.dim_customers c
ON f.customer_key = c.customer_key
GROUP BY c.customer_key,
c.first_name,
c.last_name
ORDER BY total_revenue DESC

-- What is the distribution of items sold across countries?
SELECT 
c.country,
SUM(f.quantity) total_sold_items
FROM gold.fact_sales f
LEFT JOIN
gold.dim_customers c
ON f.customer_key = c.customer_key
GROUP BY c.country
ORDER BY total_sold_items DESC

-- RANKING
-- Which 5 Products generate the highest revenue?
SELECT TOP 5
p.product_name,
SUM(f.sales_amount) total_revenue
FROM gold.fact_sales f
LEFT JOIN
gold.dim_products p
ON f.product_key = p.product_key
GROUP BY p.product_name
ORDER BY total_revenue DESC

-- What are the 5 worst performing products in terms of sales?
SELECT TOP 5
p.product_name,
SUM(f.sales_amount) total_revenue
FROM gold.fact_sales f
LEFT JOIN
gold.dim_products p
ON f.product_key = p.product_key
GROUP BY p.product_name
ORDER BY total_revenue 

SELECT TOP 5
p.product_name,
SUM(f.sales_amount) total_revenue
FROM gold.fact_sales f
LEFT JOIN
gold.dim_products p
ON f.product_key = p.product_key
GROUP BY p.product_name
ORDER BY total_revenue 


SELECT TOP 5
p.subcategory,
SUM(f.sales_amount) total_revenue
FROM gold.fact_sales f
LEFT JOIN
gold.dim_products p
ON f.product_key = p.product_key
GROUP BY p.subcategory
ORDER BY total_revenue DESC

-- Using Windows Function to find the top 5 products by revenue
 SELECT *
 FROM (   
    SELECT 
    p.product_name,
    SUM(f.sales_amount) total_revenue,
    ROW_NUMBER() OVER (ORDER BY SUM(f.sales_amount) DESC) AS revenue_rank
    FROM gold.fact_sales f
    LEFT JOIN
    gold.dim_products p
    ON f.product_key = p.product_key
    GROUP BY p.product_name)t
WHERE revenue_rank <= 5

-- Find the top 10 customers who have generated the highest revenue
SELECT TOP 10
c.customer_key,
c.first_name,
c.last_name,
SUM(f.sales_amount)total_sales_by_customer
FROM gold.fact_sales f
LEFT JOIN 
gold.dim_customers c
ON f.customer_key = c.customer_key
GROUP BY c.customer_key, c.first_name,
c.last_name
ORDER BY total_sales_by_customer DESC;

-- The 3 customers with the fewest orders placed
SELECT TOP 3
c.customer_key,
c.first_name,
c.last_name,
COUNT(DISTINCT f.order_number)total_order_by_customer
FROM gold.fact_sales f
LEFT JOIN 
gold.dim_customers c
ON f.customer_key = c.customer_key
GROUP BY c.customer_key, c.first_name,
c.last_name
ORDER BY total_order_by_customer 

-- Change Over Time Trends (Measure by Time): check how business is performing with time
-- Analyse sales performance over time
SELECT 
YEAR(order_date) AS order_year,
DATENAME(MONTH, order_date) AS order_month,
SUM(sales_amount) AS total_sales,
COUNT(DISTINCT customer_key) AS total_customers,
SUM (quantity) AS total_units_sold
FROM gold.fact_sales f
WHERE order_date IS NOT NULL
GROUP BY YEAR(order_date),DATENAME(MONTH, order_date)
ORDER BY order_year,order_month

-- Using FORMAT
SELECT
FORMAT(order_date, 'yyyy-MMM') AS order_date,
SUM(sales_amount) AS total_sales,
COUNT(DISTINCT customer_key) AS total_customers,
SUM(quantity) AS total_units_sold
FROM gold.fact_sales
WHERE order_date IS NOT NULL
GROUP BY FORMAT(order_date, 'yyyy-MMM')
ORDER BY order_date;

-- Cumulative Analysis: Cumulative Measure by Time(Date)
-- Calculate the total sales per month and the running total of sales over time.
SELECT 
DATETRUNC(MONTH, order_date) order_date,
SUM(sales_amount) as total_sales
FROM gold.fact_sales
WHERE order_date IS NOT NULL
GROUP BY DATETRUNC(MONTH, order_date)

-- The running total of sales / cumulative & Moving Average
SELECT 
order_date,
total_sales,
SUM(total_sales) OVER (ORDER BY order_date) AS running_total_sales,
avg_price,
AVG(avg_price) OVER (ORDER BY order_date) AS moving_average_price
FROM 
(   
    SELECT 
    DATETRUNC(year, order_date) order_date,
    SUM(sales_amount) as total_sales,
    AVG(price) AS avg_price
    FROM gold.fact_sales
    WHERE order_date IS NOT NULL
    GROUP BY DATETRUNC(YEAR, order_date)
)t

-- Performance Analysis: Compare the current value to a target value, compare success & performance
-- Current Measure - target measure
-- Current Sales - Average Sales
-- Current year sales - previous year sales (YOY analysis)
-- Current Sales - Lowest Sales

/*Analyse the yearly performance of products by comparing each 
products sales to both its average sales performance and the previous year's sales*/


WITH yearly_product_sales AS (
SELECT 
    YEAR(f.order_date) order_year,
    p.product_name,
    SUM(f.sales_amount) AS current_sales
    FROM gold.fact_sales f
    LEFT JOIN gold.dim_products p
    ON f.product_key = p.product_key
    WHERE YEAR(f.order_date) IS NOT NULL
    GROUP BY YEAR(f.order_date), p.product_name
)
SELECT 
order_year,
product_name,
current_sales,
AVG(current_sales) OVER (PARTITION BY product_name) AS average_sales,
current_sales - AVG(current_sales) OVER (PARTITION BY product_name) AS diff_average,
CASE 
    WHEN current_sales - AVG(current_sales) OVER (PARTITION BY product_name) > 0 THEN 'Above the Average'
    WHEN current_sales - AVG(current_sales) OVER (PARTITION BY product_name) < 0 THEN 'Below the Average'
    ELSE 'At the Average' 
END AS performance_status,
LAG(current_sales) OVER (PARTITION BY product_name ORDER BY order_year) AS previous_year_sales,
current_sales - LAG(current_sales) OVER (PARTITION BY product_name ORDER BY order_year) AS sales_difference,
CASE 
    WHEN current_sales - LAG(current_sales) OVER (PARTITION BY product_name ORDER BY order_year) > 0 THEN 'Improved'
    WHEN current_sales - LAG(current_sales) OVER (PARTITION BY product_name ORDER BY order_year) < 0 THEN 'Declined'
    ELSE 'No Change' 
END AS py_change
FROM yearly_product_sales
ORDER BY product_name, order_year;
   
-- Part to whole analysis -> contribution of each category to total sales
--Part: Indivitual category, whole: Total business
-- Measure / Total Measure * 100 = % contribution (for different dimensions)


-- Which categories contribute the most to total sales?

WITH category_sales AS (
SELECT
p.category,
SUM(sales_amount) AS total_sales
FROM gold.fact_sales f
LEFT JOIN gold.dim_products p
ON f.product_key = p.product_key
WHERE sales_amount IS NOT NULL  
GROUP BY p.category 
)
SELECT 
category,
total_sales,
SUM(total_sales) OVER () AS total_business_sales,
CONCAT(ROUND(CAST(total_sales AS FLOAT)/SUM(total_sales) OVER () * 100, 2) ,'%') AS percentage_contribution
FROM category_sales
ORDER BY total_sales DESC

-- Data Segmentation: group the data based on a specific range. helps understand the correlation between two measures.
-- Measures by measures

-- Segment products into cost ranges and count how many products fall into each segment

WITH product_segments AS (
SELECT 
product_key,
product_name,
cost,
CASE 
    WHEN cost < 100 THEN 'Below 100'
    WHEN cost BETWEEN 100 AND 500 THEN '100-500'
    WHEN cost BETWEEN 500 AND 1000 THEN '500-1000'
    ELSE 'Above 1000'
END AS cost_range
FROM gold.dim_products
) 

SELECT 
cost_range,
COUNT(product_key) AS total_products
FROM product_segments
GROUP BY cost_range
ORDER BY total_products DESC

/*Group customers into 3 segments based on their spending behaviour
VIP : atleast 12 months of history , spending more than 5000
Regular : atleast 12 months of history, spending 5000 or less
New : lifespan < 12 months 
Find total number of customers for each group*/

WITH data_segment AS (
SELECT 
c.customer_key,
SUM(f.sales_amount) AS total_spending,
MIN(order_date) first_order,
MAX(order_date) last_order,
DATEDIFF(MONTH,MIN(order_date),MAX(order_date)) AS lifespan
FROM gold.fact_sales f
LEFT JOIN
gold.dim_customers c
ON f.customer_key = c.customer_key
GROUP BY c.customer_key

) 
SELECT 
spending_behaviour,
COUNT(customer_key) AS total_customers
FROM(
    
    SELECT 
    customer_key,
    CASE 
        WHEN lifespan >= 12 AND total_spending > 5000 THEN 'VIP'
        WHEN lifespan >= 12 AND total_spending <= 5000 THEN 'Regular'
        ELSE 'New'
    END AS spending_behaviour
    FROM data_segment
)t
GROUP BY spending_behaviour
ORDER BY total_customers DESC
